<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPOTIMIX - Heatmap</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer">
</head>

<body>
    <!-- Sidebar -->
    <aside class="sidebar">
        <a class="side-icon home" href="heatmap.html" title="Heatmap">
            <i class="fa-solid fa-border-all"></i>
        </a>
        <a class="side-icon" href="bubbles.html" title="Bubbles">
            <i class="fa-solid fa-chart-pie"></i>
        </a>
        <a class="side-icon" href="timeline.html" title="Timeline">
            <i class="fa-solid fa-sliders"></i>
        </a>
        <a class="side-icon" href="scatter.html" title="Scatter">
            <i class="fa-solid fa-chart-bar"></i>
        </a>
        <a class="side-icon" href="../index.html" title="Dashboard">
            <i class="fa-solid fa-home"></i>
        </a>
    </aside>

    <!-- Topbar -->
    <header class="topbar">
        <h1 class="brand">SPOTIMIX</h1>
        <div class="toolbar">
            <label class="select">
                <select id="genre-select">
                    <option>Choisir un genre</option>
                    <!-- Les genres seront charg√©s dynamiquement -->
                </select>
            </label>
            <label class="select">
                <select id="year-min-select">
                    <option value="">Min</option>
                    <!-- Les ann√©es seront charg√©es dynamiquement -->
                </select>
            </label>
            <label class="select">
                <select id="year-max-select">
                    <option value="">Max</option>
                    <!-- Les ann√©es seront charg√©es dynamiquement -->
                </select>
            </label>
        </div>
    </header>

    <!-- Main Content -->
    <main class="dashboard" style="grid-template-columns: 1fr; grid-template-rows: 1fr;">
        <div class="panel" style="grid-column: 1; grid-row: 1;">
            <div class="panel__title">Heatmap - Analyse des caract√©ristiques musicales</div>
            <div class="panel__body">
                <div id="heatmap-container" style="width: 100%; height: 100%;"></div>
            </div>
        </div>
    </main>

    <!-- Script for Heatmap -->
    <script type="module">
        console.log('üé® Heatmap page loaded');

        // Import n√©cessaire si vous utilisez le syst√®me de modules
        // Sinon, assurez-vous que dashboard-browser.js contient les classes n√©cessaires
        
        // Variables globales pour la plage d'ann√©es
        let globalMinYear = Infinity;
        let globalMaxYear = -Infinity;
        
        // Variables globales pour les filtres actifs
        let allTracks = []; // Stocker toutes les pistes
        let currentGenreFilter = 'Choisir un genre';
        let currentYearMin = null; // Ann√©e minimale du filtre
        let currentYearMax = null; // Ann√©e maximale du filtre
        
        // Fonction principale pour initialiser la heatmap
        async function initHeatmap() {
            try {
                console.log('üîÑ Initialisation de la heatmap...');
                
                // Charger les donn√©es depuis le CSV
                const data = await d3.csv('../spotify_data.csv');
                
                // Parser les donn√©es
                const tracks = data.map(row => ({
                    artist_name: row.artist_name || '',
                    track_name: row.track_name || '',
                    track_id: row.track_id || '',
                    popularity: parseFloat(row.popularity) || 0,
                    year: parseInt(row.year) || 2000,
                    genre: row.genre || 'unknown'
                }));

                console.log(`üìä ${tracks.length} pistes charg√©es`);

                // Stocker toutes les pistes globalement pour les filtres
                allTracks = tracks;

                // Calculer la plage d'ann√©es globale (une seule fois)
                // Utiliser reduce au lieu de Math.min/max pour √©viter le stack overflow avec beaucoup de donn√©es
                globalMinYear = tracks.reduce((min, t) => !isNaN(t.year) && t.year < min ? t.year : min, Infinity);
                globalMaxYear = tracks.reduce((max, t) => !isNaN(t.year) && t.year > max ? t.year : max, -Infinity);
                console.log(`üìÖ Plage d'ann√©es: ${globalMinYear} - ${globalMaxYear}`);

                // Traiter les donn√©es pour la heatmap
                const heatmapData = processHeatmapData(tracks);
                console.log(`üìà ${heatmapData.length} cellules de heatmap cr√©√©es`);

                // Cr√©er et afficher la heatmap
                renderHeatmap(heatmapData, tracks);

                // Setup des filtres
                setupGenreFilter(tracks);
                setupYearFilter(tracks);

                console.log('‚úÖ Heatmap initialis√©e avec succ√®s');
            } catch (error) {
                console.error('‚ùå Erreur lors de l\'initialisation:', error);
                showError('Erreur lors du chargement de la heatmap');
            }
        }

        // Fonction pour traiter les donn√©es de la heatmap
        function processHeatmapData(tracks, genre = null, yearMin = null, yearMax = null) {
            // Filtrer par genre si sp√©cifi√©
            let filteredTracks = tracks;
            if (genre && genre !== 'Choisir un genre') {
                filteredTracks = filteredTracks.filter(
                    track => track.genre.toLowerCase() === genre.toLowerCase()
                );
            }
            
            // Filtrer par plage d'ann√©es si sp√©cifi√©
            if (yearMin !== null || yearMax !== null) {
                filteredTracks = filteredTracks.filter(track => {
                    const trackYear = track.year;
                    const meetsMin = yearMin === null || trackYear >= yearMin;
                    const meetsMax = yearMax === null || trackYear <= yearMax;
                    return meetsMin && meetsMax;
                });
            }

            // Grouper par artiste et ann√©e
            const groupedData = new Map();

            filteredTracks.forEach(track => {
                const key = `${track.artist_name}|${track.year}`;
                
                if (!groupedData.has(key)) {
                    groupedData.set(key, {
                        artist: track.artist_name,
                        year: track.year,
                        songs: [],
                        track_count: 0
                    });
                }

                const data = groupedData.get(key);
                data.songs.push({
                    track_name: track.track_name,
                    track_id: track.track_id,
                    popularity: track.popularity
                });
                data.track_count++;
            });

            // Traiter chaque groupe
            const heatmapCells = [];

            groupedData.forEach((data) => {
                // Trier les chansons par popularit√©
                data.songs.sort((a, b) => b.popularity - a.popularity);
                
                // Garder le top 5
                const top5Songs = data.songs.slice(0, 5);
                
                // Calculer la popularit√© moyenne
                const avgPopularity = data.songs.reduce(
                    (sum, song) => sum + song.popularity, 0
                ) / data.songs.length;

                // Calculer le rang
                const maxPopularity = data.songs[0]?.popularity || 0;
                let rank = 0;
                if (maxPopularity >= 80) rank = 4;
                else if (maxPopularity >= 60) rank = 3;
                else if (maxPopularity >= 40) rank = 2;
                else if (maxPopularity >= 20) rank = 1;

                heatmapCells.push({
                    artist: data.artist,
                    year: data.year,
                    rank: rank,
                    popular_songs: top5Songs,
                    avg_popularity: Math.round(avgPopularity),
                    track_count: data.track_count
                });
            });

            return heatmapCells;
        }

        // Fonction pour rendre la heatmap avec D3
        function renderHeatmap(data, allTracks) {
            // Limiter aux 30 artistes les plus populaires pour la lisibilit√©
            const topArtists = getTopArtists(data, 30);
            
            const container = d3.select('#heatmap-container');
            container.selectAll('*').remove();

            const margin = { top: 60, right: 150, bottom: 80, left: 220 };
            const width = 1400 - margin.left - margin.right;
            const height = 800 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Utiliser TOUTES les ann√©es de la plage globale (pas seulement celles pr√©sentes dans les donn√©es filtr√©es)
            const allYears = [];
            for (let year = globalMinYear; year <= globalMaxYear; year++) {
                allYears.push(year);
            }
            
            const artists = getUniqueArtists(topArtists);

            // Cr√©er un Map pour acc√®s rapide aux donn√©es
            const dataMap = new Map();
            topArtists.forEach(d => {
                dataMap.set(`${d.artist}-${d.year}`, d);
            });

            // Cr√©er un dataset complet avec toutes les combinaisons artiste/ann√©e
            const completeData = [];
            artists.forEach(artist => {
                allYears.forEach(year => {
                    const key = `${artist}-${year}`;
                    const existingData = dataMap.get(key);
                    if (existingData) {
                        completeData.push(existingData);
                    } else {
                        // Cellule vide - pas de donn√©es pour cet artiste cette ann√©e
                        completeData.push({
                            artist: artist,
                            year: year,
                            rank: -1, // -1 indique "pas de donn√©es"
                            popular_songs: [],
                            avg_popularity: 0,
                            track_count: 0
                        });
                    }
                });
            });

            // √âchelles
            const xScale = d3.scaleBand()
                .domain(allYears.map(String))
                .range([0, width])
                .padding(0.05);

            const yScale = d3.scaleBand()
                .domain(artists)
                .range([0, height])
                .padding(0.05);

            // NOUVELLES COULEURS selon vos sp√©cifications
            // R√©cup√©rer les couleurs depuis les variables CSS
            const rootStyles = getComputedStyle(document.documentElement);
            const colors = {
                noData: rootStyles.getPropertyValue('--heatmap-no-data').trim(),
                range0: rootStyles.getPropertyValue('--heatmap-0-20').trim(),
                range1: rootStyles.getPropertyValue('--heatmap-20-40').trim(),
                range2: rootStyles.getPropertyValue('--heatmap-40-60').trim(),
                range3: rootStyles.getPropertyValue('--heatmap-60-80').trim(),
                range4: rootStyles.getPropertyValue('--heatmap-80-100').trim()
            };

            const colorScale = d3.scaleThreshold()
                .domain([0, 20, 40, 60, 80, 100])
                .range([
                    colors.noData,   // Pas de donn√©es
                    colors.range0,   // 0-20
                    colors.range1,   // 20-40
                    colors.range2,   // 40-60
                    colors.range3,   // 60-80
                    colors.range4    // 80-100
                ]);
            
            // Fonction pour obtenir la couleur en fonction du rang ou de l'avg_popularity
            function getColor(d) {
                if (d.rank === -1 || d.track_count === 0) {
                    return colors.noData; // Pas de donn√©es
                }

                // Utiliser avg_popularity pour plus de pr√©cision
                return colorScale(d.avg_popularity);
            }

            // Cr√©er tooltip
            const tooltip = createTooltip();

            // Dessiner les cellules
            g.selectAll('.heatmap-cell')
                .data(completeData)
                .enter()
                .append('rect')
                .attr('class', 'heatmap-cell')
                .attr('x', d => xScale(String(d.year)))
                .attr('y', d => yScale(d.artist))
                .attr('width', xScale.bandwidth())
                .attr('height', yScale.bandwidth())
                .attr('fill', d => getColor(d))
                .attr('stroke', '#1a1a1a')
                .attr('stroke-width', 1)
                .attr('rx', 2)
                .style('cursor', d => d.rank === -1 ? 'default' : 'pointer')
                .on('mouseover', function(event, d) {
                    if (d.rank !== -1) {
                        d3.select(this).attr('stroke', '#fff').attr('stroke-width', 3);
                        showTooltip(event, d, tooltip);
                    }
                })
                .on('mouseout', function(event, d) {
                    d3.select(this).attr('stroke', '#1a1a1a').attr('stroke-width', 1);
                    tooltip.style('visibility', 'hidden');
                })
                .on('click', (event, d) => {
                    if (d.rank !== -1) {
                        showDetailModal(d);
                    }
                });

            // Axes
            g.append('g')
                .attr('class', 'x-axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale))
                .selectAll('text')
                .style('text-anchor', 'end')
                .attr('dx', '-0.8em')
                .attr('dy', '0.15em')
                .attr('transform', 'rotate(-45)')
                .style('fill', '#e2e2e2')
                .style('font-size', '11px');

            g.append('g')
                .attr('class', 'y-axis')
                .call(d3.axisLeft(yScale))
                .selectAll('text')
                .style('fill', '#e2e2e2')
                .style('font-size', '11px');

            // Styling des axes
            g.selectAll('.x-axis .domain, .y-axis .domain, .x-axis .tick line, .y-axis .tick line')
                .style('stroke', '#535353');

            // Titre
            g.append('text')
                .attr('x', width / 2)
                .attr('y', -30)
                .attr('text-anchor', 'middle')
                .style('fill', '#e2e2e2')
                .style('font-size', '18px')
                .style('font-weight', 'bold')
                .text('Popularit√© des artistes par ann√©e');

            // Labels
            g.append('text')
                .attr('x', width / 2)
                .attr('y', height + 60)
                .attr('text-anchor', 'middle')
                .style('fill', '#e2e2e2')
                .style('font-size', '13px')
                .text('Ann√©e');

            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -160)
                .attr('text-anchor', 'middle')
                .style('fill', '#e2e2e2')
                .style('font-size', '13px')
                .text('Artiste');

            // L√©gende
            drawLegend(g, colorScale, width);
        }

        function getTopArtists(cells, topN) {
            const artistStats = new Map();

            cells.forEach(cell => {
                if (!artistStats.has(cell.artist)) {
                    artistStats.set(cell.artist, { total: 0, count: 0 });
                }
                const stats = artistStats.get(cell.artist);
                stats.total += cell.avg_popularity;
                stats.count++;
            });

            const sortedArtists = Array.from(artistStats.entries())
                .map(([artist, stats]) => ({
                    artist,
                    avgPopularity: stats.total / stats.count
                }))
                .sort((a, b) => b.avgPopularity - a.avgPopularity)
                .slice(0, topN)
                .map(item => item.artist);

            return cells.filter(cell => sortedArtists.includes(cell.artist));
        }

        function getUniqueArtists(cells) {
            const artistStats = new Map();

            cells.forEach(cell => {
                if (!artistStats.has(cell.artist)) {
                    artistStats.set(cell.artist, { total: 0, count: 0 });
                }
                const stats = artistStats.get(cell.artist);
                stats.total += cell.avg_popularity;
                stats.count++;
            });

            return Array.from(artistStats.entries())
                .map(([artist, stats]) => ({
                    artist,
                    avgPopularity: stats.total / stats.count
                }))
                .sort((a, b) => b.avgPopularity - a.avgPopularity)
                .map(item => item.artist);
        }

        function drawLegend(g, colorScale, width) {
            const legend = g.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${width + 20}, 0)`);

            legend.append('text')
                .attr('y', 0)
                .style('fill', '#e2e2e2')
                .style('font-size', '12px')
                .style('font-weight', 'bold')
                .text('Popularit√©');

            // R√©cup√©rer les couleurs depuis CSS
            const rootStyles = getComputedStyle(document.documentElement);
            const legendData = [
                { color: rootStyles.getPropertyValue('--heatmap-80-100').trim(), label: '80 - 100' },
                { color: rootStyles.getPropertyValue('--heatmap-60-80').trim(), label: '60 - 80' },
                { color: rootStyles.getPropertyValue('--heatmap-40-60').trim(), label: '40 - 60' },
                { color: rootStyles.getPropertyValue('--heatmap-20-40').trim(), label: '20 - 40' },
                { color: rootStyles.getPropertyValue('--heatmap-0-20').trim(), label: '0 - 20' },
                { color: rootStyles.getPropertyValue('--heatmap-no-data').trim(), label: 'Pas de donn√©es' }
            ];

            legendData.forEach((item, i) => {
                const legendItem = legend.append('g')
                    .attr('transform', `translate(0, ${i * 35 + 20})`);

                legendItem.append('rect')
                    .attr('width', 25)
                    .attr('height', 25)
                    .attr('fill', item.color)
                    .attr('stroke', '#1a1a1a')
                    .attr('rx', 2);

                legendItem.append('text')
                    .attr('x', 32)
                    .attr('y', 17)
                    .style('fill', '#e2e2e2')
                    .style('font-size', '10px')
                    .text(item.label);
            });
        }

        function createTooltip() {
            d3.select('#heatmap-tooltip').remove();
            return d3.select('body')
                .append('div')
                .attr('id', 'heatmap-tooltip')
                .style('position', 'absolute')
                .style('visibility', 'hidden')
                .style('background-color', 'rgba(0, 0, 0, 0.9)')
                .style('color', '#fff')
                .style('padding', '12px')
                .style('border-radius', '8px')
                .style('font-size', '13px')
                .style('pointer-events', 'none')
                .style('z-index', '1000')
                .style('max-width', '300px');
        }

        function showTooltip(event, d, tooltip) {
            const topSongs = d.popular_songs
                .slice(0, 5)
                .map((song, i) => `${i + 1}. ${song.track_name} (${song.popularity})`)
                .join('<br/>');

            const content = `
                <div style="font-weight: bold; margin-bottom: 6px; border-bottom: 1px solid #555; padding-bottom: 6px;">
                    ${d.artist} - ${d.year}
                </div>
                <div style="margin-bottom: 4px;"><strong>Rang:</strong> ${d.rank} / 4</div>
                <div style="margin-bottom: 4px;"><strong>Popularit√© moy.:</strong> ${d.avg_popularity}</div>
                <div style="margin-bottom: 4px;"><strong>Nb chansons:</strong> ${d.track_count}</div>
                <div style="margin-top: 8px; padding-top: 6px; border-top: 1px solid #555;">
                    <strong>Top chansons:</strong><br/>
                    <div style="margin-top: 4px; font-size: 11px;">${topSongs}</div>
                </div>
            `;

            tooltip.html(content)
                .style('visibility', 'visible')
                .style('left', `${event.pageX + 10}px`)
                .style('top', `${event.pageY - 10}px`);
        }

        function showDetailModal(data) {
            d3.select('#detail-modal').remove();
            d3.select('#modal-backdrop').remove();

            const backdrop = d3.select('body')
                .append('div')
                .attr('id', 'modal-backdrop')
                .style('position', 'fixed')
                .style('top', '0')
                .style('left', '0')
                .style('width', '100%')
                .style('height', '100%')
                .style('background-color', 'rgba(0, 0, 0, 0.7)')
                .style('z-index', '1999')
                .on('click', closeModal);

            const modal = d3.select('body')
                .append('div')
                .attr('id', 'detail-modal')
                .style('position', 'fixed')
                .style('top', '50%')
                .style('left', '50%')
                .style('transform', 'translate(-50%, -50%)')
                .style('background-color', 'var(--bg-light, #353a50)')
                .style('padding', '30px')
                .style('border-radius', '15px')
                .style('box-shadow', '0 10px 40px rgba(0,0,0,0.5)')
                .style('z-index', '2000')
                .style('max-width', '500px')
                .style('max-height', '80vh')
                .style('overflow-y', 'auto')
                .style('color', 'var(--text, #e2e2e2)');

            modal.append('h2')
                .style('margin-top', '0')
                .style('color', 'var(--accent-1, #6eb6ff)')
                .text(`${data.artist} - ${data.year}`);

            modal.append('div')
                .style('margin-bottom', '20px')
                .html(`
                    <p><strong>Rang:</strong> ${data.rank} / 4</p>
                    <p><strong>Popularit√© moyenne:</strong> ${data.avg_popularity}</p>
                    <p><strong>Nombre de chansons:</strong> ${data.track_count}</p>
                `);

            modal.append('h3')
                .style('color', 'var(--accent-2, #ff6ad5)')
                .text('Top chansons:');

            const list = modal.append('ol').style('padding-left', '20px');
            data.popular_songs.forEach(song => {
                list.append('li')
                    .style('margin-bottom', '8px')
                    .html(`
                        <strong>${song.track_name}</strong><br/>
                        <span style="color: var(--accent-4, #5be7a9); font-size: 12px;">
                            Popularit√©: ${song.popularity}
                        </span>
                    `);
            });

            modal.append('button')
                .style('margin-top', '20px')
                .style('padding', '10px 20px')
                .style('background-color', 'var(--violet, #7972a8)')
                .style('color', '#fff')
                .style('border', 'none')
                .style('border-radius', '8px')
                .style('cursor', 'pointer')
                .text('Fermer')
                .on('click', closeModal);
        }

        function closeModal() {
            d3.select('#detail-modal').remove();
            d3.select('#modal-backdrop').remove();
        }

        function setupGenreFilter(tracks) {
            const genreSelect = d3.select('#genre-select');
            
            // Extraire tous les genres uniques et les trier
            const uniqueGenres = [...new Set(tracks.map(track => track.genre))]
                .filter(genre => genre && genre !== 'unknown')
                .sort((a, b) => a.localeCompare(b));
            
            console.log(`üéµ ${uniqueGenres.length} genres trouv√©s:`, uniqueGenres);
            
            // Ajouter chaque genre au select
            uniqueGenres.forEach(genre => {
                genreSelect.append('option')
                    .text(genre.charAt(0).toUpperCase() + genre.slice(1)) // Capitalize
                    .attr('value', genre);
            });
            
            // G√©rer le changement de filtre
            genreSelect.on('change', function() {
                currentGenreFilter = this.value;
                console.log('Genre s√©lectionn√©:', currentGenreFilter);
                
                applyFilters();
            });
        }

        function setupYearFilter(tracks) {
            const yearMinSelect = d3.select('#year-min-select');
            const yearMaxSelect = d3.select('#year-max-select');
            
            // Extraire toutes les ann√©es uniques et les trier
            const uniqueYears = [...new Set(tracks.map(track => track.year))]
                .filter(year => !isNaN(year))
                .sort((a, b) => a - b);
            
            console.log(`üìÖ ${uniqueYears.length} ann√©es trouv√©es: ${uniqueYears[0]} - ${uniqueYears[uniqueYears.length - 1]}`);
            
            // Ajouter chaque ann√©e aux deux selects
            uniqueYears.forEach(year => {
                yearMinSelect.append('option')
                    .text(year)
                    .attr('value', year);
                    
                yearMaxSelect.append('option')
                    .text(year)
                    .attr('value', year);
            });
            
            // G√©rer le changement de filtre min
            yearMinSelect.on('change', function() {
                const selectedMin = this.value ? parseInt(this.value) : null;
                
                // Si on r√©initialise Min (s√©lection de "Min")
                if (selectedMin === null) {
                    currentYearMin = null;
                    console.log('Ann√©e min r√©initialis√©e');
                    // R√©activer toutes les options de Max
                    updateYearMaxOptions(uniqueYears, null);
                    applyFilters();
                    return;
                }
                
                // Si min > max, r√©initialiser max automatiquement
                if (currentYearMax !== null && selectedMin > currentYearMax) {
                    console.log(`‚ö†Ô∏è Min (${selectedMin}) > Max (${currentYearMax}), r√©initialisation de Max`);
                    yearMaxSelect.property('value', '');
                    currentYearMax = null;
                }
                
                currentYearMin = selectedMin;
                console.log('Ann√©e min s√©lectionn√©e:', currentYearMin);
                
                // Mettre √† jour les options du select max
                updateYearMaxOptions(uniqueYears, currentYearMin);
                
                applyFilters();
            });
            
            // G√©rer le changement de filtre max
            yearMaxSelect.on('change', function() {
                const selectedMax = this.value ? parseInt(this.value) : null;
                
                // Si on r√©initialise Max (s√©lection de "Max")
                if (selectedMax === null) {
                    currentYearMax = null;
                    console.log('Ann√©e max r√©initialis√©e');
                    // R√©activer toutes les options de Min
                    updateYearMinOptions(uniqueYears, null);
                    applyFilters();
                    return;
                }
                
                // Si max < min, r√©initialiser min automatiquement
                if (currentYearMin !== null && selectedMax < currentYearMin) {
                    console.log(`‚ö†Ô∏è Max (${selectedMax}) < Min (${currentYearMin}), r√©initialisation de Min`);
                    yearMinSelect.property('value', '');
                    currentYearMin = null;
                }
                
                currentYearMax = selectedMax;
                console.log('Ann√©e max s√©lectionn√©e:', currentYearMax);
                
                // Mettre √† jour les options du select min
                updateYearMinOptions(uniqueYears, currentYearMax);
                
                applyFilters();
            });
            
            // Fonction pour mettre √† jour les options du select min
            function updateYearMinOptions(years, maxYear) {
                yearMinSelect.selectAll('option:not([value=""])').remove();
                
                years.forEach(year => {
                    const option = yearMinSelect.append('option')
                        .text(year)
                        .attr('value', year);
                    
                    // D√©sactiver les ann√©es > max
                    if (maxYear !== null && year > maxYear) {
                        option.attr('disabled', 'disabled')
                            .style('color', '#999');
                    }
                });
            }
            
            // Fonction pour mettre √† jour les options du select max
            function updateYearMaxOptions(years, minYear) {
                yearMaxSelect.selectAll('option:not([value=""])').remove();
                
                years.forEach(year => {
                    const option = yearMaxSelect.append('option')
                        .text(year)
                        .attr('value', year);
                    
                    // D√©sactiver les ann√©es < min
                    if (minYear !== null && year < minYear) {
                        option.attr('disabled', 'disabled')
                            .style('color', '#999');
                    }
                });
            }
        }

        function applyFilters() {
            const yearRangeText = currentYearMin || currentYearMax 
                ? `${currentYearMin || '‚àû'} - ${currentYearMax || '‚àû'}` 
                : 'Toutes';
            console.log(`üîç Application des filtres: Genre="${currentGenreFilter}", Plage ann√©es="${yearRangeText}"`);
            
            const heatmapData = processHeatmapData(allTracks, currentGenreFilter, currentYearMin, currentYearMax);
            renderHeatmap(heatmapData, allTracks);
        }

        function showError(message) {
            const container = d3.select('#heatmap-container');
            container.selectAll('*').remove();
            container.append('div')
                .style('color', 'red')
                .style('padding', '20px')
                .style('text-align', 'center')
                .text(`‚ùå ${message}`);
        }

        // Initialiser au chargement de la page
        initHeatmap();
    </script>
</body>

</html>
