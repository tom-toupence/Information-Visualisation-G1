<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline Tempo - Spotimix</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer">
    <link rel="stylesheet" href="../style.css">
    <style>
        .tempo-timeline-page {
            margin-left: 60px;
            margin-top: 60px;
            padding: 20px;
            height: calc(100vh - 80px);
        }

        .page-header {
            margin-bottom: 20px;
        }

        .page-header h2 {
            color: var(--accent-4);
            margin-bottom: 10px;
        }

        .page-header p {
            color: var(--text);
            font-size: 14px;
            line-height: 1.5;
        }

        #tempo-timeline-full {
            width: 100%;
            height: calc(100% - 180px);
            background: var(--bg-light);
            border-radius: 15px;
            padding: 20px;
            box-shadow: var(--shadow-1);
            overflow-x: auto;
            overflow-y: hidden;
        }
        
        /* Scrollbar horizontale stylis√©e */
        #tempo-timeline-full::-webkit-scrollbar {
            height: 14px;
        }
        
        #tempo-timeline-full::-webkit-scrollbar-track {
            background: var(--bg);
            border-radius: 7px;
        }
        
        #tempo-timeline-full::-webkit-scrollbar-thumb {
            background: var(--accent-3);
            border-radius: 7px;
        }
        
        #tempo-timeline-full::-webkit-scrollbar-thumb:hover {
            background: var(--accent-1);
        }

        .tempo-controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            background: var(--bg-light);
            padding: 15px;
            border-radius: 15px;
            box-shadow: var(--shadow-1);
        }

        .tempo-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tempo-input label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text);
        }

        .tempo-input input {
            padding: 8px 12px;
            border: 1px solid var(--grey);
            border-radius: 8px;
            font-size: 14px;
            width: 80px;
            background: var(--bg);
            color: var(--text);
        }

        .tempo-input button {
            padding: 8px 16px;
            background: var(--accent-4);
            color: var(--bg);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .tempo-input button:hover {
            background: var(--accent-1);
            transform: translateY(-1px);
        }

        .tempo-point {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tempo-point:hover {
            stroke-width: 3px !important;
        }

        .tempo-reference-line {
            stroke: #ff6b6b;
            stroke-width: 2;
            stroke-dasharray: 5,5;
        }

        .timeline-base {
            stroke: #333;
            stroke-width: 1;
        }

        .legend {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            font-size: 12px;
            background: var(--bg-light);
            color: var(--text);
            padding: 10px;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid #fff;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            max-width: 200px;
        }
    </style>
</head>
<body>
    <!-- Sidebar -->
    <aside class="sidebar">
        <a class="side-icon" href="../index.html" title="Retour Dashboard">
            <i class="fa-solid fa-home"></i>
        </a>
        <a class="side-icon" href="heatmap.html" title="Graph 1">
            <i class="fa-solid fa-border-all"></i>
        </a>
        <a class="side-icon" href="bubbles.html" title="Graph 2">
            <i class="fa-solid fa-chart-pie"></i>
        </a>
        <a class="side-icon home active" href="#" title="Timeline Tempo">
            <i class="fa-solid fa-sliders"></i>
        </a>
        <a class="side-icon" href="scatter.html" title="Graph 4">
            <i class="fa-solid fa-chart-bar"></i>
        </a>
    </aside>

    <!-- Topbar -->
    <header class="topbar">
        <h1 class="brand">SPOTIMIX - Timeline Tempo</h1>
        <label class="select">
            <select id="genre-filter">
                <option>Choisir un genre</option>
                <option>Pop</option>
                <option>Rock</option>
                <option>Rap</option>
                <option>Electro</option>
                <option>Hip-Hop</option>
                <option>Acoustic</option>
                <option>Funk</option>
                <option>R&B</option>
                <option>Electronic</option>
                <option>Indie</option>
                <option>Country</option>
                <option>Jazz</option>
                <option>Blues</option>
                <option>Classical</option>
            </select>
        </label>
    </header>

    <!-- Contenu principal -->
    <main class="tempo-timeline-page">
        <div class="page-header">
            <h2>Timeline des Tempos - Transitions Musicales</h2>
            <p>Trouvez rapidement des morceaux populaires avec un tempo proche pour des transitions propres. La ligne rouge indique le tempo de r√©f√©rence. Cliquez sur un morceau pour le d√©finir comme nouveau tempo de r√©f√©rence.</p>
        </div>

        <div class="tempo-controls">
            <div class="tempo-input">
                <label for="current-tempo">Tempo de r√©f√©rence :</label>
                <input type="number" id="current-tempo" value="120" min="60" max="200">
                <span>BPM</span>
                <button id="update-tempo">Centrer</button>
            </div>

            <div class="tempo-input">
                <button id="scroll-left">‚Üê -5 BPM</button>
                <button id="scroll-right">+5 BPM ‚Üí</button>
            </div>
            <div id="viewport-info" style="font-size: 12px; color: #666; margin-left: 15px;">
                Vue: 110-130 BPM | Zoom: 1.0x | Morceaux: 0
            </div>
        </div>

        <div id="tempo-timeline-full"></div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #6eb6ff;"></div>
                <span>Pop</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6ad5;"></div>
                <span>Rock</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8e98c9;"></div>
                <span>Hip-Hop</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #5be7a9;"></div>
                <span>Rap</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #6eb6ff;"></div>
                <span>Electro/Electronic</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #ff6ad5;"></div>
                <span>Acoustic</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8e98c9;"></div>
                <span>Funk</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #5be7a9;"></div>
                <span>R&B</span>
            </div>
        </div>
    </main>

    <!-- Tooltip -->
    <div id="tooltip" class="tooltip"></div>

    <!-- Scripts -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        class TempoTimelineChart {
            constructor(containerId, config = {}) {
                this.config = {
                    width: 1200,
                    height: 200,
                    margin: { top: 20, right: 30, bottom: 50, left: 60 },
                    ...config
                };
                
                this.data = [];
                this.currentTempo = 120;
                this.viewportMin = 110;
                this.viewportMax = 130;
                this.zoomLevel = 1;
                this.timelineHeight = 0; // Sera calcul√© dynamiquement au centre
                
                this.container = d3.select(`#${containerId}`);
                this.tooltip = d3.select('#tooltip');
                
                this.createSVG();
                this.setupInteractions();
            }
            
            createSVG() {
                this.svg = this.container
                    .append('svg')
                    .attr('width', this.config.width)
                    .attr('height', this.config.height);
                    
                this.g = this.svg.append('g')
                    .attr('transform', `translate(${this.config.margin.left},${this.config.margin.top})`);
                    
                this.innerWidth = this.config.width - this.config.margin.left - this.config.margin.right;
                this.innerHeight = this.config.height - this.config.margin.top - this.config.margin.bottom;
                
                // Calculer la position de la timeline au centre du graphique
                this.timelineHeight = this.innerHeight / 2;
            }

            setupInteractions() {
                // Pas de zoom sur molette, seulement les boutons de zoom
                // La navigation se fait avec la barre de scroll
            }
            
            setData(data) {
                this.data = data;
                return this;
            }
            
            setCurrentTempo(tempo) {
                this.currentTempo = tempo;
                // Centrer la scrollbar sur le tempo s√©lectionn√©
                this.centerScrollOnTempo(tempo);
                return this;
            }
            
            centerScrollOnTempo(tempo) {
                const container = document.getElementById('tempo-timeline-full');
                if (container) {
                    const tempoPosition = this.tempoScale(tempo);
                    const scrollPosition = tempoPosition - container.clientWidth / 2;
                    container.scrollLeft = Math.max(0, Math.min(container.scrollWidth - container.clientWidth, scrollPosition));
                }
            }
            
            render() {
                this.createScales();
                this.drawChart();
                this.drawAxes();
                this.updateViewportInfo();
                return this;
            }
            
            createScales() {
                // Focus+Context : largeur fixe avec zone centrale d√©taill√©e
                const fullRange = 200 - 60; // 140 BPM
                const pixelsPerBPM = 6; // 6 pixels par BPM fixe
                const fullWidth = fullRange * pixelsPerBPM;
                
                // Mettre √† jour la largeur du SVG
                this.svg.attr('width', fullWidth + this.config.margin.left + this.config.margin.right);
                this.innerWidth = fullWidth;
                
                // Recalculer la position centrale de la timeline
                this.timelineHeight = this.innerHeight / 2;
                
                this.tempoScale = d3.scaleLinear()
                    .domain([60, 200])
                    .range([0, this.innerWidth]);
                    
                // Calculer les zones focus et context
                this.focusCenter = this.currentTempo;
                this.focusMin = this.focusCenter - 2;
                this.focusMax = this.focusCenter + 2;
                this.focusStartX = this.tempoScale(this.focusMin);
                this.focusEndX = this.tempoScale(this.focusMax);
                this.focusWidth = this.focusEndX - this.focusStartX;
            }
            
            getTracksForCurrentView() {
                const genreSelect = document.getElementById('genre-filter');
                const selectedGenre = genreSelect.value;
                
                // Filtrer seulement par genre (afficher toute la plage de tempos)
                const filteredTracks = this.data.filter(track => {
                    if (selectedGenre !== 'Choisir un genre' && 
                        track.genre.toLowerCase() !== selectedGenre.toLowerCase()) return false;
                    return true;
                });

                // Seuil de popularit√© plus bas pour avoir plus de diversit√©
                const popularityThreshold = 30;

                return filteredTracks
                    .filter(track => track.popularity >= popularityThreshold)
                    .sort((a, b) => b.popularity - a.popularity);
            }

            arrangeTracksOnTimeline(tracks) {
                const grouped = new Map();
                
                tracks.forEach(track => {
                    const roundedTempo = Math.round(track.tempo * 2) / 2;
                    if (!grouped.has(roundedTempo)) {
                        grouped.set(roundedTempo, []);
                    }
                    grouped.get(roundedTempo).push(track);
                });

                return Array.from(grouped.entries()).map(([tempo, tracks]) => {
                    const sortedTracks = tracks.sort((a, b) => b.popularity - a.popularity);
                    
                    // Dans la zone focus, garder jusqu'√† 5 tracks par tempo
                    // Dans la zone context, garder seulement la plus populaire
                    const focusMinTempo = this.currentTempo - 2;
                    const focusMaxTempo = this.currentTempo + 2;
                    const isInFocus = tempo >= focusMinTempo && tempo <= focusMaxTempo;
                    
                    return {
                        tempo,
                        tracks: isInFocus ? sortedTracks.slice(0, 5) : [sortedTracks[0]]
                    };
                });
            }
            
            drawChart() {
                const tracksToShow = this.getTracksForCurrentView();
                
                // Nettoyer
                this.g.selectAll('*').remove();

                // Ligne de base timeline
                this.g.append('line')
                    .attr('class', 'timeline-base')
                    .attr('x1', 0)
                    .attr('x2', this.innerWidth)
                    .attr('y1', this.timelineHeight)
                    .attr('y2', this.timelineHeight)
                    .attr('stroke', '#e2e2e2')
                    .attr('stroke-width', 3);

                // Zone de focus (60% du milieu) - Rectangle de surbrillance
                const focusZoneWidth = this.innerWidth * 0.6;
                const focusZoneStart = (this.innerWidth - focusZoneWidth) / 2;
                
                this.g.append('rect')
                    .attr('class', 'focus-zone')
                    .attr('x', focusZoneStart)
                    .attr('y', 20)
                    .attr('width', focusZoneWidth)
                    .attr('height', this.innerHeight - 40)
                    .attr('fill', 'rgba(255, 106, 213, 0.1)') // --accent-2 transparent
                    .attr('stroke', '#ff6ad5')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '10,5');

                // Ligne de r√©f√©rence (toujours visible maintenant)
                this.g.append('line')
                    .attr('class', 'tempo-reference-line')
                    .attr('x1', this.tempoScale(this.currentTempo))
                    .attr('x2', this.tempoScale(this.currentTempo))
                    .attr('y1', 20)
                    .attr('y2', this.innerHeight - 20)
                    .attr('stroke', '#ff6ad5')
                    .attr('stroke-width', 3)
                    .attr('stroke-dasharray', '5,5');

                // Calculer les zones
                const focusMinTempo = this.currentTempo - 2;
                const focusMaxTempo = this.currentTempo + 2;

                // S√©parer les tracks en zones focus et context
                const focusTracks = [];
                const contextTracks = [];
                
                tracksToShow.forEach(track => {
                    if (track.tempo >= focusMinTempo && track.tempo <= focusMaxTempo) {
                        focusTracks.push(track);
                    } else {
                        contextTracks.push(track);
                    }
                });

                // Dessiner la zone context (traits simples)
                this.drawContextTracks(contextTracks);
                
                // Dessiner la zone focus (boules d√©taill√©es)
                this.drawFocusTracks(focusTracks);
            }
            
            drawContextTracks(tracks) {
                const self = this;
                const tracksByTempo = this.arrangeTracksOnTimeline(tracks);
                
                tracksByTempo.forEach(d => {
                    const x = this.tempoScale(d.tempo);
                    const track = d.tracks[0];
                    
                    // Simple trait vertical pour la zone context
                    this.g.append('line')
                        .attr('class', 'context-track')
                        .attr('x1', x)
                        .attr('x2', x)
                        .attr('y1', this.timelineHeight - 15)
                        .attr('y2', this.timelineHeight + 15)
                        .attr('stroke', self.getGenreColor(track.genre))
                        .attr('stroke-width', Math.max(2, track.popularity / 25))
                        .attr('opacity', 0.6);
                });
            }
            
            drawFocusTracks(tracks) {
                const self = this;
                const tracksByTempo = this.arrangeTracksOnTimeline(tracks);
                
                tracksByTempo.forEach(d => {
                    const x = this.tempoScale(d.tempo);
                    const track = d.tracks[0];
                    
                    // Cr√©er groupe pour chaque track
                    const group = this.g.append('g')
                        .attr('class', 'focus-track-group')
                        .attr('transform', `translate(${x}, 0)`);
                    
                    // √âtaler les tracks verticalement si plusieurs au m√™me tempo
                    const yPositions = this.calculateVerticalPositions(d.tracks, this.timelineHeight);
                    
                    d.tracks.forEach((track, index) => {
                        const y = yPositions[index];
                        
                        // Boule d√©taill√©e pour la zone focus
                        group.append('circle')
                            .attr('class', 'focus-point')
                            .attr('cx', 0)
                            .attr('cy', y)
                            .attr('r', Math.max(6, track.popularity / 10))
                            .attr('fill', self.getGenreColor(track.genre))
                            .attr('stroke', '#white')
                            .attr('stroke-width', 2)
                            .style('cursor', 'pointer')
                            .datum(track)
                            .on('mouseover', (event, d) => self.showTooltip(event, d))
                            .on('mouseout', () => self.hideTooltip())
                            .on('click', (event, d) => self.onTrackClick(d));
                        
                        // Ligne de connexion √† la timeline si pas sur la ligne centrale
                        if (y !== self.timelineHeight) {
                            group.append('line')
                                .attr('x1', 0)
                                .attr('x2', 0)
                                .attr('y1', self.timelineHeight)
                                .attr('y2', y)
                                .attr('stroke', self.getGenreColor(track.genre))
                                .attr('stroke-width', 1)
                                .attr('opacity', 0.4);
                        }
                        
                        // Label d'artiste
                        group.append('text')
                            .attr('x', 0)
                            .attr('y', y - 12)
                            .attr('text-anchor', 'middle')
                            .attr('font-size', '9px')
                            .attr('fill', '#e2e2e2')
                            .text(track.artist_name)
                            .style('pointer-events', 'none');
                    });
                });
            }
            
            calculateVerticalPositions(tracks, centerY) {
                if (tracks.length === 1) return [centerY];
                
                const spacing = 25;
                const positions = [];
                const startY = centerY - ((tracks.length - 1) * spacing) / 2;
                
                for (let i = 0; i < tracks.length; i++) {
                    positions.push(startY + i * spacing);
                }
                
                return positions;
            }
            
            drawAxes() {
                // Axe X uniquement
                this.g.append('g')
                    .attr('class', 'x-axis')
                    .attr('transform', `translate(0,${this.innerHeight - 10})`)
                    .call(d3.axisBottom(this.tempoScale)
                        .tickFormat(d => `${d} BPM`)
                        .tickSize(-this.innerHeight + 20)
                    )
                    .selectAll('.tick line')
                    .attr('stroke', '#535353')
                    .attr('stroke-width', 1);

                // Label
                this.g.append('text')
                    .attr('x', this.innerWidth / 2)
                    .attr('y', this.innerHeight + 25)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '12px')
                    .attr('fill', '#535353')
                    .text(`Tempo (BPM) - Zoom: ${this.zoomLevel.toFixed(1)}x`);
            }
            
            getGenreColor(genre) {
                // Utilisation des couleurs d'accent d√©finies dans style.css
                const colors = {
                    'pop': '#6eb6ff',       // --accent-1 (bleu)
                    'rock': '#ff6ad5',      // --accent-2 (rose)
                    'hip-hop': '#8e98c9',   // --accent-3 (mauve/gris)
                    'rap': '#5be7a9',       // --accent-4 (vert menthe)
                    'electro': '#6eb6ff',   // --accent-1 (bleu)
                    'electronic': '#6eb6ff', // --accent-1 (bleu)
                    'acoustic': '#ff6ad5',  // --accent-2 (rose)
                    'funk': '#8e98c9',      // --accent-3 (mauve/gris)
                    'r&b': '#5be7a9',       // --accent-4 (vert menthe)
                    'indie': '#6eb6ff',     // --accent-1 (bleu)
                    'country': '#ff6ad5',   // --accent-2 (rose)
                    'jazz': '#8e98c9',      // --accent-3 (mauve/gris)
                    'blues': '#5be7a9',     // --accent-4 (vert menthe)
                    'classical': '#8e98c9'  // --accent-3 (mauve/gris)
                };
                return colors[genre.toLowerCase()] || '#8e98c9'; // --accent-3 par d√©faut
            }
            
            showTooltip(event, d) {
                this.tooltip
                    .style('opacity', 1)
                    .html(`
                        <strong>${d.track_name}</strong><br/>
                        <span style="color: #5be7a9;">${d.artist_name}</span><br/>
                        <span style="color: #ff6ad5;">üéµ ${Math.round(d.tempo)} BPM</span><br/>
                        ‚≠ê Popularit√©: ${d.popularity}%<br/>
                        üé∂ Genre: ${d.genre}
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            }
            
            hideTooltip() {
                this.tooltip.style('opacity', 0);
            }
            
            onTrackClick(track) {
                console.log('üéµ Morceau s√©lectionn√© pour transition:', track);
                this.setCurrentTempo(track.tempo);
                document.getElementById('current-tempo').value = Math.round(track.tempo);
                this.render();
            }

            // M√©thodes de navigation

            scrollLeft() {
                const container = document.getElementById('tempo-timeline-full');
                if (container) {
                    container.scrollLeft = Math.max(0, container.scrollLeft - 100);
                }
            }

            scrollRight() {
                const container = document.getElementById('tempo-timeline-full');
                if (container) {
                    container.scrollLeft = Math.min(container.scrollWidth - container.clientWidth, container.scrollLeft + 100);
                }
            }

            updateViewportInfo() {
                const info = document.getElementById('viewport-info');
                const tracksCount = this.getTracksForCurrentView().length;
                const container = document.getElementById('tempo-timeline-full');
                let scrollInfo = '';
                
                if (container && container.scrollWidth > container.clientWidth) {
                    const scrollPercent = ((container.scrollLeft / (container.scrollWidth - container.clientWidth)) * 100).toFixed(0);
                    scrollInfo = ` | Scroll: ${scrollPercent}%`;
                }
                
                const focusRange = `${(this.currentTempo - 2).toFixed(1)}-${(this.currentTempo + 2).toFixed(1)}`;
                info.textContent = `Vue: 60-200 BPM | Focus: ${focusRange} BPM | Morceaux: ${tracksCount}${scrollInfo}`;
            }
            
            update() {
                this.render();
            }
        }

        // Classe principale de la page
        class TempoTimelinePage {
            constructor() {
                this.allTracks = [];
                this.chart = null;
                this.currentTempo = 120;
                this.popularityThreshold = 50;
            }

            async init() {
                try {
                    console.log('üöÄ Initialisation de la page Timeline Tempo...');
                    await this.loadData();
                    this.createChart();
                    this.setupControls();
                    console.log('‚úÖ Page Timeline Tempo initialis√©e');
                } catch (error) {
                    console.error('‚ùå Erreur lors de l\'initialisation:', error);
                    this.showError('Erreur lors du chargement des donn√©es');
                }
            }

            async loadData() {
                try {
                    // Charger les donn√©es CSV
                    const data = await d3.csv('../spotify_data.csv');
                    this.allTracks = data.map(row => ({
                        artist_name: row.artist_name || '',
                        track_name: row.track_name || '',
                        track_id: row.track_id || '',
                        popularity: parseInt(row.popularity) || 0,
                        year: parseInt(row.year) || 2000,
                        genre: row.genre || 'unknown',
                        tempo: parseFloat(row.tempo) || 120,
                        danceability: parseFloat(row.danceability) || 0,
                        energy: parseFloat(row.energy) || 0,
                        valence: parseFloat(row.valence) || 0
                    }));
                    
                    console.log(`üìä ${this.allTracks.length} pistes charg√©es`);
                } catch (error) {
                    console.error('Erreur chargement CSV:', error);
                    // Donn√©es de d√©monstration en cas d'erreur
                    this.allTracks = this.getDefaultData();
                }
            }
            
            getDefaultData() {
                return [
                    { artist_name: "Ed Sheeran", track_name: "Shape of You", track_id: "1", popularity: 93, year: 2017, genre: "pop", tempo: 95.977 },
                    { artist_name: "The Weeknd", track_name: "Blinding Lights", track_id: "2", popularity: 88, year: 2019, genre: "pop", tempo: 171.009 },
                    { artist_name: "Dua Lipa", track_name: "Levitating", track_id: "3", popularity: 85, year: 2020, genre: "pop", tempo: 103.0 },
                    { artist_name: "Justin Bieber", track_name: "Peaches", track_id: "4", popularity: 80, year: 2021, genre: "pop", tempo: 90.0 },
                    { artist_name: "Ariana Grande", track_name: "7 rings", track_id: "5", popularity: 78, year: 2019, genre: "pop", tempo: 140.0 },
                    { artist_name: "Miley Cyrus", track_name: "Flowers", track_id: "6", popularity: 75, year: 2023, genre: "pop", tempo: 96.0 }
                ];
            }

            createChart() {
                const containerHeight = window.innerHeight - 300;
                // Largeur initiale, sera ajust√©e dynamiquement selon le zoom
                const initialWidth = 1400; // 140 BPM * 10 pixels par BPM

                this.chart = new TempoTimelineChart('tempo-timeline-full', {
                    width: initialWidth,
                    height: Math.max(400, containerHeight)
                });

                this.chart.popularityThreshold = this.popularityThreshold;
                this.chart.setData(this.allTracks);
                this.chart.render();
                this.chart.setCurrentTempo(this.currentTempo);
            }

            setupControls() {
                // Contr√¥le du tempo de r√©f√©rence
                document.getElementById('update-tempo').addEventListener('click', () => {
                    const tempoInput = document.getElementById('current-tempo');
                    const tempo = parseInt(tempoInput.value) || 120;
                    this.chart.setCurrentTempo(tempo);
                    this.chart.render();
                });

                // Contr√¥les de scroll
                document.getElementById('scroll-left').addEventListener('click', () => {
                    this.chart.scrollLeft();
                });

                document.getElementById('scroll-right').addEventListener('click', () => {
                    this.chart.scrollRight();
                });

                // Filtre par genre
                document.getElementById('genre-filter').addEventListener('change', () => {
                    this.chart.render();
                });

                // Support clavier
                document.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.chart.scrollLeft();
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            this.chart.scrollRight();
                            break;

                    }
                });

                // Enter key pour tempo
                document.getElementById('current-tempo').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('update-tempo').click();
                    }
                });
            }
            
            showError(message) {
                const container = document.querySelector('.tempo-timeline-page');
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = 'color: red; padding: 20px; text-align: center; background: #fff; border-radius: 8px; margin: 20px 0;';
                errorDiv.textContent = `‚ùå ${message}`;
                container.insertBefore(errorDiv, container.firstChild);
            }
        }

        // Initialiser la page
        const tempoTimelinePage = new TempoTimelinePage();
        tempoTimelinePage.init();
    </script>
</body>
</html>